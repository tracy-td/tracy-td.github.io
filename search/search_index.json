{"config":{"indexing":"full","lang":["pt"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documenta\u00e7\u00e3o: Tracy-TD Ger\u00eancia de D\u00edvidas T\u00e9cnicas Orientada a Neg\u00f3cios subt\u00edtulo acesse: http://ayty.org Contribuindo \u00cdndice: Iniciando Obtendo ajuda Come\u00e7ando a contribuir Iniciando o desnvolvimento Criando uma issue Atribuindo uma issue Contribuindo com o c\u00f3digo Contribuindo com a documenta\u00e7\u00e3o Implementa\u00e7\u00e3o dos testes Iniciando Aconselhamos que ap\u00f3s a leitura desse arquivo, voc\u00ea d\u00ea uma olhada nas issues iniciais do projeto, e siga os exemplos de como contribuir com o c\u00f3digo. Obtendo ajuda A comunidade de contribui\u00e7\u00f5es da Tracy-TD possui um canal de comunica\u00e7\u00e3o no Discord , assim novos integrantes podem tirar suas d\u00favidas e interagir com outros membros. Come\u00e7ando a contribuir Para voc\u00ea que \u00e9 iniciante, sugerimos que pegue uma issue simples para come\u00e7ar a se familiarizar com o projeto. As issues para os iniciantes se encontram neste link (COLOCAR O LINK), essas issues possuem a Labels de \"good first issue\". Iniciando o desenvolvimento Para iniciar o desenvolvimento \u00e9 necess\u00e1rio criar uma branch. Existem dois tipos de branches: feature e bugfix: feature: Prefixo de branch para nova funcionalidade ou melhoria; Nova funcionalidade: Uma nova fun\u00e7\u00e3o para a API; Melhoria: Melhoria de uma fun\u00e7\u00e3o j\u00e1 existente ou parte do c\u00f3digo. bugfix: Prefixo de branch que corrige algum bug em c\u00f3digo. Sabendo dos prefixos de cada tipo de issue, preencha o sufixo do nome da branch com \"/#\" seguido do n\u00famero da Issue. Exemplo: feature/#xxxx , bugfix/#yyyy . Criando uma branch via terminal: - git checkout - b \\<nome da branch> - Esse comando cria a branch com o nome passado no par\u00e2metro (n\u00e3o utilize os \"<>\") e ainda troca para branch atual de uso. Criando issue Se voc\u00ea encontrou algum bug ou quer sugerir alguma funcionalidade, voc\u00ea pode criar uma issue nesse LINK (botar o link) Para criar uma nova Issue, voc\u00ea pode seguir os seguintes passos, todos os passos a seguir come\u00e7am ao acessar a aba de Issues , ou j\u00e1 no template de New issue do reposit\u00f3rio: Dentro do template de New issue, no input de \"Title\", escreva brevimente o que a nova issue deve fazer, e ent\u00e3o no input de \"Leave a comment\", fa\u00e7a uma descri\u00e7\u00e3o mais detalhada sobre como a issue deve ser executada/implementada. Ap\u00f3s as especifica\u00e7\u00f5es da nova issue, ao lado direito existe alguns complementos importantes: - Em \"Assignees\" voc\u00ea pode escolher a pessoa respons\u00e1vel para a execu\u00e7\u00e3o da issue, caso o objetivo seja apenas deixar a issue registrada, n\u00e3o precisa atribuir, caso queira pegar uma issue, siga para se\u00e7\u00e3o atribuindo uma issue . - Em \"Labels\" voc\u00ea define que tipo de feature e caracteristica essa issue possui, como \"bug\", para uma issue referente a um bug no sistema, \"documentation\" issue que mexe com algum arquivo refente a documenta\u00e7\u00e3o do projeto, \"enhancement\", para issue referente a uma nova feature ou melhoria para o sistema, existem varias labels e. Issue podem receber varias labels e n\u00e3o s\u00e3o obrigat\u00f3rias para a cria\u00e7\u00e3o de uma. Ap\u00f3s esses passos a sua issue est\u00e1 pronta para ser criada, clique em \"Submite new issue\" e receba a nova issue com um \"#\" seguido de um valor num\u00e9rico, um identificador para a issue, e este identificador ser\u00e1 utilizado no coment\u00e1rio do seu Pull Request para ser feito o link entre a issue e o Pull Request. Atribuindo uma issue Para atribuir uma issue, voc\u00ea precisa acessa a aba de Issues , ao selecionar uma issue, ela ser\u00e1 aberta e poder\u00e1 receber atribui\u00e7\u00e3o(\u00f5es) ao clicar em \"Assignees\", ent\u00e3o selecionar quem dever\u00e1 fazer parte do desenvolvimento dessa issue. Lembrando que em Assigness, n\u00e3o ser\u00e3o as mesmas pessoas que ir\u00e3o revisar o seu Pull Request . Fazendo Pull Request Ao concluir a sua contribui\u00e7\u00e3o \u00e9 hora de fazer o famoso Pull Request, onde ele ser\u00e1 revisado pela comunidade e ent\u00e3o, se tudo estiver de acordo com as expectativas dos revisadores o Pull Request ser\u00e1 aceito. Mas para isso, \u00e9 preciso seguir alguns passos primeiro, \u00e9 preciso preparar os arquivos que ser\u00e3o adicionados para o commit e consequentemente para o Pull Request/Revis\u00e3o, com os seguintes passos no terminal: git add \"{nome do arquivo}\" ou git add . , que adiciona o arquivo menscionado ou todos os arquivos salvos e modificados ao Stage, tamb\u00e9m pode ser chamado de Index ou Staging Area: O Staging Area \u00e9 um lugar onde os arquivos est\u00e3o sendo preparados para o commit. git commit -m \"{mensagem do commit}\" , com esse comando voc\u00ea transfere seus arquivos para o diret\u00f3rio local do git com uma mensagem sobre o commit, muito importante que essa mensagem contenha informa\u00e7\u00f5es sobre as altera\u00e7\u00f5es feitas e referencie a issue associada a contribui\u00e7\u00e3o: A mensagem do commit deve conter uma refer\u00eancia a issue, essa refer\u00eancia \u00e9 feita atraves de # seguido do n\u00famero de identifica\u00e7\u00e3o da issue no github, seguido de uma breve descri\u00e7\u00e3o do que foi feito. git push , com o git push, os arquivos ser\u00e3o enviados para o reposit\u00f3rio da nuvem do github: \u00c9 possivel que pe\u00e7a suas credenciais, informe elas e continue o procedimento; Caso a branch ainda n\u00e3o exista no reposit\u00f3rio do github, ser\u00e1 exibido uma mensagem para no terminal para publicar a branch, copie a mensagem e execute para subir suas altera\u00e7\u00f5es; No reposit\u00f3rio do github do projeto, ao estar logado com as credenciais iguais as informadas, ser\u00e1 exibido uma mensagem informado que existe um Pull Request para ser solicitado... Contribuindo com o c\u00f3digo Para contribui\u00e7\u00e3o de c\u00f3digo temos 3 categorias para uma issue: - Nova funcionalidade, s\u00e3o acressimos de novas fun\u00e7\u00f5es ou recursos que ainda n\u00e3o existem no projeto, e possui como titulo da branch \"feature\". - Melhoria, s\u00e3o mudna\u00e7as em fun\u00e7\u00f5es ou recursos que \u00e1 existem no projeto, possuindo o titulo de branch \"feature\". - Bug, os bugs s\u00e3o dividos em dois, cr\u00edticos e n\u00e3o cr\u00edticos, ambos possuiem o titulo de branch \"bugfix\": - Cr\u00edticos, afetam gravimente alguma funcionalidade importante do sistema, o que torna a aplica\u00e7\u00e3o inutilizavel ou de dificil acesso. - N\u00e3o cr\u00edticos, s\u00e3o os bugs que causam apenas um leve incomodo na aplica\u00e7\u00e3o, onde n\u00e3o chegam a causar tanto impacto na funcionalidade. Contribuindo com a documenta\u00e7\u00e3o A documenta\u00e7\u00e3o de um software sempre muda de acordo com as novas funcionalidades que s\u00e3o desenvolvidas, desta forma, atualiza\u00e7\u00f5es s\u00e3o necess\u00e1rias para que o software e documenta\u00e7\u00e3o estejam sempre alinhados, essa \u00e9 um tipo de contribui\u00e7\u00e3o importante para manter a integridade entre os desenvolvedores e quem faz uso da ferramenta. Veja a documenta\u00e7\u00e3o aqui.(COLOCAR LINK) Outros arquivos como o README, C\u00f3digo de condulta e o este guia de contribui\u00e7\u00f5es podem receber novas altera\u00e7\u00f5es se forem necess\u00e1rias, abra uma issue e comece a contribuir agora mesmo. Como criar um relat\u00f3rio de bug Implementa\u00e7\u00e3o dos testes TODO isso aqui \u00e9 um md a parte que terar um link para ser acessado daqui","title":"Documenta\u00e7\u00e3o: Tracy-TD"},{"location":"#documentacao-tracy-td","text":"Ger\u00eancia de D\u00edvidas T\u00e9cnicas Orientada a Neg\u00f3cios","title":"Documenta\u00e7\u00e3o: Tracy-TD"},{"location":"#subtitulo","text":"acesse: http://ayty.org","title":"subt\u00edtulo"},{"location":"#contribuindo","text":"","title":"Contribuindo"},{"location":"#indice","text":"Iniciando Obtendo ajuda Come\u00e7ando a contribuir Iniciando o desnvolvimento Criando uma issue Atribuindo uma issue Contribuindo com o c\u00f3digo Contribuindo com a documenta\u00e7\u00e3o Implementa\u00e7\u00e3o dos testes","title":"\u00cdndice:"},{"location":"#iniciando","text":"Aconselhamos que ap\u00f3s a leitura desse arquivo, voc\u00ea d\u00ea uma olhada nas issues iniciais do projeto, e siga os exemplos de como contribuir com o c\u00f3digo.","title":"Iniciando"},{"location":"#obtendo-ajuda","text":"A comunidade de contribui\u00e7\u00f5es da Tracy-TD possui um canal de comunica\u00e7\u00e3o no Discord , assim novos integrantes podem tirar suas d\u00favidas e interagir com outros membros.","title":"Obtendo ajuda"},{"location":"#comecando-a-contribuir","text":"Para voc\u00ea que \u00e9 iniciante, sugerimos que pegue uma issue simples para come\u00e7ar a se familiarizar com o projeto. As issues para os iniciantes se encontram neste link (COLOCAR O LINK), essas issues possuem a Labels de \"good first issue\".","title":"Come\u00e7ando a contribuir"},{"location":"#iniciando-o-desenvolvimento","text":"Para iniciar o desenvolvimento \u00e9 necess\u00e1rio criar uma branch. Existem dois tipos de branches: feature e bugfix: feature: Prefixo de branch para nova funcionalidade ou melhoria; Nova funcionalidade: Uma nova fun\u00e7\u00e3o para a API; Melhoria: Melhoria de uma fun\u00e7\u00e3o j\u00e1 existente ou parte do c\u00f3digo. bugfix: Prefixo de branch que corrige algum bug em c\u00f3digo. Sabendo dos prefixos de cada tipo de issue, preencha o sufixo do nome da branch com \"/#\" seguido do n\u00famero da Issue. Exemplo: feature/#xxxx , bugfix/#yyyy . Criando uma branch via terminal: - git checkout - b \\<nome da branch> - Esse comando cria a branch com o nome passado no par\u00e2metro (n\u00e3o utilize os \"<>\") e ainda troca para branch atual de uso.","title":"Iniciando o desenvolvimento"},{"location":"#criando-issue","text":"Se voc\u00ea encontrou algum bug ou quer sugerir alguma funcionalidade, voc\u00ea pode criar uma issue nesse LINK (botar o link) Para criar uma nova Issue, voc\u00ea pode seguir os seguintes passos, todos os passos a seguir come\u00e7am ao acessar a aba de Issues , ou j\u00e1 no template de New issue do reposit\u00f3rio: Dentro do template de New issue, no input de \"Title\", escreva brevimente o que a nova issue deve fazer, e ent\u00e3o no input de \"Leave a comment\", fa\u00e7a uma descri\u00e7\u00e3o mais detalhada sobre como a issue deve ser executada/implementada. Ap\u00f3s as especifica\u00e7\u00f5es da nova issue, ao lado direito existe alguns complementos importantes: - Em \"Assignees\" voc\u00ea pode escolher a pessoa respons\u00e1vel para a execu\u00e7\u00e3o da issue, caso o objetivo seja apenas deixar a issue registrada, n\u00e3o precisa atribuir, caso queira pegar uma issue, siga para se\u00e7\u00e3o atribuindo uma issue . - Em \"Labels\" voc\u00ea define que tipo de feature e caracteristica essa issue possui, como \"bug\", para uma issue referente a um bug no sistema, \"documentation\" issue que mexe com algum arquivo refente a documenta\u00e7\u00e3o do projeto, \"enhancement\", para issue referente a uma nova feature ou melhoria para o sistema, existem varias labels e. Issue podem receber varias labels e n\u00e3o s\u00e3o obrigat\u00f3rias para a cria\u00e7\u00e3o de uma. Ap\u00f3s esses passos a sua issue est\u00e1 pronta para ser criada, clique em \"Submite new issue\" e receba a nova issue com um \"#\" seguido de um valor num\u00e9rico, um identificador para a issue, e este identificador ser\u00e1 utilizado no coment\u00e1rio do seu Pull Request para ser feito o link entre a issue e o Pull Request.","title":"Criando issue"},{"location":"#atribuindo-uma-issue","text":"Para atribuir uma issue, voc\u00ea precisa acessa a aba de Issues , ao selecionar uma issue, ela ser\u00e1 aberta e poder\u00e1 receber atribui\u00e7\u00e3o(\u00f5es) ao clicar em \"Assignees\", ent\u00e3o selecionar quem dever\u00e1 fazer parte do desenvolvimento dessa issue. Lembrando que em Assigness, n\u00e3o ser\u00e3o as mesmas pessoas que ir\u00e3o revisar o seu Pull Request .","title":"Atribuindo uma issue"},{"location":"#fazendo-pull-request","text":"Ao concluir a sua contribui\u00e7\u00e3o \u00e9 hora de fazer o famoso Pull Request, onde ele ser\u00e1 revisado pela comunidade e ent\u00e3o, se tudo estiver de acordo com as expectativas dos revisadores o Pull Request ser\u00e1 aceito. Mas para isso, \u00e9 preciso seguir alguns passos primeiro, \u00e9 preciso preparar os arquivos que ser\u00e3o adicionados para o commit e consequentemente para o Pull Request/Revis\u00e3o, com os seguintes passos no terminal: git add \"{nome do arquivo}\" ou git add . , que adiciona o arquivo menscionado ou todos os arquivos salvos e modificados ao Stage, tamb\u00e9m pode ser chamado de Index ou Staging Area: O Staging Area \u00e9 um lugar onde os arquivos est\u00e3o sendo preparados para o commit. git commit -m \"{mensagem do commit}\" , com esse comando voc\u00ea transfere seus arquivos para o diret\u00f3rio local do git com uma mensagem sobre o commit, muito importante que essa mensagem contenha informa\u00e7\u00f5es sobre as altera\u00e7\u00f5es feitas e referencie a issue associada a contribui\u00e7\u00e3o: A mensagem do commit deve conter uma refer\u00eancia a issue, essa refer\u00eancia \u00e9 feita atraves de # seguido do n\u00famero de identifica\u00e7\u00e3o da issue no github, seguido de uma breve descri\u00e7\u00e3o do que foi feito. git push , com o git push, os arquivos ser\u00e3o enviados para o reposit\u00f3rio da nuvem do github: \u00c9 possivel que pe\u00e7a suas credenciais, informe elas e continue o procedimento; Caso a branch ainda n\u00e3o exista no reposit\u00f3rio do github, ser\u00e1 exibido uma mensagem para no terminal para publicar a branch, copie a mensagem e execute para subir suas altera\u00e7\u00f5es; No reposit\u00f3rio do github do projeto, ao estar logado com as credenciais iguais as informadas, ser\u00e1 exibido uma mensagem informado que existe um Pull Request para ser solicitado...","title":"Fazendo Pull Request"},{"location":"#contribuindo-com-o-codigo","text":"Para contribui\u00e7\u00e3o de c\u00f3digo temos 3 categorias para uma issue: - Nova funcionalidade, s\u00e3o acressimos de novas fun\u00e7\u00f5es ou recursos que ainda n\u00e3o existem no projeto, e possui como titulo da branch \"feature\". - Melhoria, s\u00e3o mudna\u00e7as em fun\u00e7\u00f5es ou recursos que \u00e1 existem no projeto, possuindo o titulo de branch \"feature\". - Bug, os bugs s\u00e3o dividos em dois, cr\u00edticos e n\u00e3o cr\u00edticos, ambos possuiem o titulo de branch \"bugfix\": - Cr\u00edticos, afetam gravimente alguma funcionalidade importante do sistema, o que torna a aplica\u00e7\u00e3o inutilizavel ou de dificil acesso. - N\u00e3o cr\u00edticos, s\u00e3o os bugs que causam apenas um leve incomodo na aplica\u00e7\u00e3o, onde n\u00e3o chegam a causar tanto impacto na funcionalidade.","title":"Contribuindo com o c\u00f3digo"},{"location":"#contribuindo-com-a-documentacao","text":"A documenta\u00e7\u00e3o de um software sempre muda de acordo com as novas funcionalidades que s\u00e3o desenvolvidas, desta forma, atualiza\u00e7\u00f5es s\u00e3o necess\u00e1rias para que o software e documenta\u00e7\u00e3o estejam sempre alinhados, essa \u00e9 um tipo de contribui\u00e7\u00e3o importante para manter a integridade entre os desenvolvedores e quem faz uso da ferramenta. Veja a documenta\u00e7\u00e3o aqui.(COLOCAR LINK) Outros arquivos como o README, C\u00f3digo de condulta e o este guia de contribui\u00e7\u00f5es podem receber novas altera\u00e7\u00f5es se forem necess\u00e1rias, abra uma issue e comece a contribuir agora mesmo.","title":"Contribuindo com a documenta\u00e7\u00e3o"},{"location":"#como-criar-um-relatorio-de-bug","text":"","title":"Como criar um relat\u00f3rio de bug"},{"location":"#implementacao-dos-testes","text":"TODO isso aqui \u00e9 um md a parte que terar um link para ser acessado daqui","title":"Implementa\u00e7\u00e3o dos testes"},{"location":"CODE-OF-CONDUCT/","text":"C\u00f3digo de conduta Nossos votos Com objetivo de proporcionar um ambiente receptivo e confortavel, nos contribuidores e mantedores, comprometemos de tornar a nossa participa\u00e7\u00e3o no projeto livre de ass\u00e9dio para todos, independetemente da idade, corpo, tamanho, defici\u00eancia, etnia, caracter\u00edsticas sexuais, identidade e express\u00e3o de g\u00eanero, nivel de experi\u00eancia, educa\u00e7\u00e3o, status socioecon\u00f4mico, nacionalidade, apar\u00eancia, ra\u00e7a, religi\u00e3o ou identidade e orienta\u00e7\u00e3o sexual. Padr\u00f5es comportamentais Exemplos de comportamentos que ajudam a manter o ambiente aconchegante: Uso de uma linguagem acolhedora e inclusiva Respeitar os diferentes pontos de vista e experi\u00eancia Aceitando cr\u00edticas construtivas com eleg\u00e2ncia e maturidade Foco no que \u00e9 melhor para a comunidade Mostrar empatia para com outros membros da comunidade Exemplos de comportamentos inaceit\u00e1veis por parte dos participantes incluem: O uso de linguagem ou imagens sexualizadas e aten\u00e7\u00e3o sexual indesejada ou avan\u00e7os. Trolls, coment\u00e1rios insultuosos / depreciativos e ataques pessoais ou politicos. Ass\u00e9dio public ou privado Publica\u00e7\u00e3o de informa\u00e7\u00f5es privadas de terceiros, como um f\u00edsico ou endere\u00e7o eletr\u00f4nico, sem permiss\u00e3o expl\u00edcita. Outra conduta que poderia ser razoavelmente considerada inadequada em um ambiente profissional. Responsabilidades Os mantedores do projeto s\u00e3o responsaveis por esclarecer os padr\u00f5es de comportamento e devem tomar as medida corretivas, adequadas e justas em resposta a quaisquer inst\u00e2ncia de comportamento inaceit\u00e1vel. Os mantedores do projeto tem o direito e responsabilidade de remover, editar ou rejeitar coment\u00e1rios, confirma\u00e7\u00f5es, c\u00f3digo, edi\u00e7\u00f5es de wiki, problemas e outras contribui\u00e7\u00f5es que n\u00e3o estejam alinhados com este C\u00f3digo de Conduta, ou para banir temporariamente ou permanentemente qualquer contribuidor com comportamentos inadequeados, amea\u00e7ador, ofensivo ou prejudicial.","title":"C\u00f3digo de conduta"},{"location":"CODE-OF-CONDUCT/#codigo-de-conduta","text":"","title":"C\u00f3digo de conduta"},{"location":"CODE-OF-CONDUCT/#nossos-votos","text":"Com objetivo de proporcionar um ambiente receptivo e confortavel, nos contribuidores e mantedores, comprometemos de tornar a nossa participa\u00e7\u00e3o no projeto livre de ass\u00e9dio para todos, independetemente da idade, corpo, tamanho, defici\u00eancia, etnia, caracter\u00edsticas sexuais, identidade e express\u00e3o de g\u00eanero, nivel de experi\u00eancia, educa\u00e7\u00e3o, status socioecon\u00f4mico, nacionalidade, apar\u00eancia, ra\u00e7a, religi\u00e3o ou identidade e orienta\u00e7\u00e3o sexual.","title":"Nossos votos"},{"location":"CODE-OF-CONDUCT/#padroes-comportamentais","text":"Exemplos de comportamentos que ajudam a manter o ambiente aconchegante: Uso de uma linguagem acolhedora e inclusiva Respeitar os diferentes pontos de vista e experi\u00eancia Aceitando cr\u00edticas construtivas com eleg\u00e2ncia e maturidade Foco no que \u00e9 melhor para a comunidade Mostrar empatia para com outros membros da comunidade Exemplos de comportamentos inaceit\u00e1veis por parte dos participantes incluem: O uso de linguagem ou imagens sexualizadas e aten\u00e7\u00e3o sexual indesejada ou avan\u00e7os. Trolls, coment\u00e1rios insultuosos / depreciativos e ataques pessoais ou politicos. Ass\u00e9dio public ou privado Publica\u00e7\u00e3o de informa\u00e7\u00f5es privadas de terceiros, como um f\u00edsico ou endere\u00e7o eletr\u00f4nico, sem permiss\u00e3o expl\u00edcita. Outra conduta que poderia ser razoavelmente considerada inadequada em um ambiente profissional.","title":"Padr\u00f5es comportamentais"},{"location":"CODE-OF-CONDUCT/#responsabilidades","text":"Os mantedores do projeto s\u00e3o responsaveis por esclarecer os padr\u00f5es de comportamento e devem tomar as medida corretivas, adequadas e justas em resposta a quaisquer inst\u00e2ncia de comportamento inaceit\u00e1vel. Os mantedores do projeto tem o direito e responsabilidade de remover, editar ou rejeitar coment\u00e1rios, confirma\u00e7\u00f5es, c\u00f3digo, edi\u00e7\u00f5es de wiki, problemas e outras contribui\u00e7\u00f5es que n\u00e3o estejam alinhados com este C\u00f3digo de Conduta, ou para banir temporariamente ou permanentemente qualquer contribuidor com comportamentos inadequeados, amea\u00e7ador, ofensivo ou prejudicial.","title":"Responsabilidades"},{"location":"CONTRIBUTING/","text":"Contribuindo \u00cdndice: Iniciando Obtendo ajuda Come\u00e7ando a contribuir Iniciando o desnvolvimento Criando uma issue Atribuindo uma issue Contribuindo com o c\u00f3digo Contribuindo com a documenta\u00e7\u00e3o Implementa\u00e7\u00e3o dos testes Iniciando Aconcelhamos que ap\u00f3s a leitura desse arquivo, voc\u00ea de uma olhada nas issues iniciais do projeto, e siga os exemplos de como contribuir com o c\u00f3digo. Obtendo ajuda A comunidade de contribui\u00e7\u00f5es da Tracy-TD possui um canal de comunica\u00e7\u00e3o no Discord , assim novos integrantes podem tirar suas d\u00favidas e interagir com outros membros. Come\u00e7ando a contribuir Para voc\u00ea que \u00e9 iniciante, sugerimos que pegue uma issue simples, para come\u00e7ar a se familiarizar com o projeto, as issue para os iniciantes se encontram neste link (COLOCAR O LINK), essas issues possuem a Labels \"good first issue\". Iniciando o desenvolvimento Para iniciar o desenvolvimento \u00e9 necess\u00e1rio criar uma branch, existe como padr\u00e3o, dois tipos de branchs, feature e bugfix: feature: Prefixo de branch para nova funcionalidade ou melhoria; Nova funcionalidade: Uma nova fun\u00e7\u00e3o para a API a qual ainda n\u00e3o existe; Melhoria: Melhoria de uma fun\u00e7\u00e3o j\u00e1 existente ou parte do c\u00f3digo. bugfix: Prefixo de branch que corrige algum bug em c\u00f3digo. Sabendo dos prefixos de cada tipo de issue, preencha o sufixo do nome da branch com \"/\" seguido do n\u00famero da Issue. Exemplo: \"feature/xxxx\", \"bugfix/yyyy\". Criando uma branch via terminal: - git checkout - b \\ - Esse comando cria a branch com o nome passado no par\u00e2metro (n\u00e3o utilizar os \"<>\") e ainda troca para branch atual de uso. Criando issue Se voc\u00ea encontrou algum bug ou quer sugerir alguma funcionalidade, voc\u00ea pode criar uma issue nesse LINK (botar o link) Para criar uma nova Issue, voc\u00ea pode seguir os seguintes passos, todos os passos a seguir come\u00e7am ao acessar a aba de Issues , ou j\u00e1 no template de New issue do reposit\u00f3rio: Dentro do template de New issue, no input de \"Title\", escreva brevimente o que a nova issue deve fazer, e ent\u00e3o no input de \"Leave a comment\", fa\u00e7a uma descri\u00e7\u00e3o mais detalhada sobre como a issue deve ser executada/implementada. Ap\u00f3s as especifica\u00e7\u00f5es da nova issue, ao lado direito existe alguns complementos importantes: - Em \"Assignees\" voc\u00ea pode escolher a pessoa respons\u00e1vel para a execu\u00e7\u00e3o da issue, caso o objetivo seja apenas deixar a issue registrada, n\u00e3o precisa atribuir, caso queira pegar uma issue, siga para se\u00e7\u00e3o atribuindo uma issue . - Em \"Labels\" voc\u00ea define que tipo de feature e caracteristica essa issue possui, como \"bug\", para uma issue referente a um bug no sistema, \"documentation\" issue que mexe com algum arquivo refente a documenta\u00e7\u00e3o do projeto, \"enhancement\", para issue referente a uma nova feature ou melhoria para o sistema, existem varias labels e. Issue podem receber varias labels e n\u00e3o s\u00e3o obrigat\u00f3rias para a cria\u00e7\u00e3o de uma. Ap\u00f3s esses passos a sua issue est\u00e1 pronta para ser criada, clique em \"Submite new issue\" e receba a nova issue com um \"#\" seguido de um valor num\u00e9rico, um identificador para a issue, e este identificador ser\u00e1 utilizado no coment\u00e1rio do seu Pull Request para ser feito o link entre a issue e o Pull Request. Atribuindo uma issue Para atribuir uma issue, voc\u00ea precisa acessa a aba de Issues , ao selecionar uma issue, ela ser\u00e1 aberta e poder\u00e1 receber atribui\u00e7\u00e3o(\u00f5es) ao clicar em \"Assignees\", ent\u00e3o selecionar quem dever\u00e1 fazer parte do desenvolvimento dessa issue. Lembrando que em Assigness, n\u00e3o ser\u00e3o as mesmas pessoas que ir\u00e3o revisar o seu Pull Request . Fazendo Pull Request Ao concluir a sua contribui\u00e7\u00e3o \u00e9 hora de fazer o famoso Pull Request, onde ele ser\u00e1 revisado pela comunidade e ent\u00e3o, se tudo estiver de acordo com as expectativas dos revisadores o Pull Request ser\u00e1 aceito. Mas para isso, \u00e9 preciso seguir alguns passos primeiro, \u00e9 preciso preparar os arquivos que ser\u00e3o adicionados para o commit e consequentemente para o Pull Request/Revis\u00e3o, com os seguintes passos no terminal: git add \"{nome do arquivo}\" ou git add . , que adiciona o arquivo menscionado ou todos os arquivos salvos e modificados ao Stage, tamb\u00e9m pode ser chamado de Index ou Staging Area: O Staging Area \u00e9 um lugar onde os arquivos est\u00e3o sendo preparados para o commit. git commit -m \"{mensagem do commit}\" , com esse comando voc\u00ea transfere seus arquivos para o diret\u00f3rio local do git com uma mensagem sobre o commit, muito importante que essa mensagem contenha informa\u00e7\u00f5es sobre as altera\u00e7\u00f5es feitas e referencie a issue associada a contribui\u00e7\u00e3o: A mensagem do commit deve conter uma refer\u00eancia a issue, essa refer\u00eancia \u00e9 feita atraves de # seguido do n\u00famero de identifica\u00e7\u00e3o da issue no github, seguido de uma breve descri\u00e7\u00e3o do que foi feito. git push , com o git push, os arquivos ser\u00e3o enviados para o reposit\u00f3rio da nuvem do github: \u00c9 possivel que pe\u00e7a suas credenciais, informe elas e continue o procedimento; Caso a branch ainda n\u00e3o exista no reposit\u00f3rio do github, ser\u00e1 exibido uma mensagem para no terminal para publicar a branch, copie a mensagem e execute para subir suas altera\u00e7\u00f5es; No reposit\u00f3rio do github do projeto, ao estar logado com as credenciais iguais as informadas, ser\u00e1 exibido uma mensagem informado que existe um Pull Request para ser solicitado... Contribuindo com o c\u00f3digo Para contribui\u00e7\u00e3o de c\u00f3digo temos 3 categorias para uma issue: - Nova funcionalidade, s\u00e3o acressimos de novas fun\u00e7\u00f5es ou recursos que ainda n\u00e3o existem no projeto, e possui como titulo da branch \"feature\". - Melhoria, s\u00e3o mudna\u00e7as em fun\u00e7\u00f5es ou recursos que \u00e1 existem no projeto, possuindo o titulo de branch \"feature\". - Bug, os bugs s\u00e3o dividos em dois, cr\u00edticos e n\u00e3o cr\u00edticos, ambos possuiem o titulo de branch \"bugfix\": - Cr\u00edticos, afetam gravimente alguma funcionalidade importante do sistema, o que torna a aplica\u00e7\u00e3o inutilizavel ou de dificil acesso. - N\u00e3o cr\u00edticos, s\u00e3o os bugs que causam apenas um leve incomodo na aplica\u00e7\u00e3o, onde n\u00e3o chegam a causar tanto impacto na funcionalidade. Contribuindo com a documenta\u00e7\u00e3o A documenta\u00e7\u00e3o de um software sempre muda de acordo com as novas funcionalidades que s\u00e3o desenvolvidas, desta forma, atualiza\u00e7\u00f5es s\u00e3o necess\u00e1rias para que o software e documenta\u00e7\u00e3o estejam sempre alinhados, essa \u00e9 um tipo de contribui\u00e7\u00e3o importante para manter a integridade entre os desenvolvedores e quem faz uso da ferramenta. Veja a documenta\u00e7\u00e3o aqui.(COLOCAR LINK) Outros arquivos como o README, C\u00f3digo de condulta e o este guia de contribui\u00e7\u00f5es podem receber novas altera\u00e7\u00f5es se forem necess\u00e1rias, abra uma issue e comece a contribuir agora mesmo. Como criar um relat\u00f3rio de bug Implementa\u00e7\u00e3o dos testes TODO isso aqui \u00e9 um md a parte que terar um link para ser acessado daqui","title":"Contribuindo"},{"location":"CONTRIBUTING/#contribuindo","text":"","title":"Contribuindo"},{"location":"CONTRIBUTING/#indice","text":"Iniciando Obtendo ajuda Come\u00e7ando a contribuir Iniciando o desnvolvimento Criando uma issue Atribuindo uma issue Contribuindo com o c\u00f3digo Contribuindo com a documenta\u00e7\u00e3o Implementa\u00e7\u00e3o dos testes","title":"\u00cdndice:"},{"location":"CONTRIBUTING/#iniciando","text":"Aconcelhamos que ap\u00f3s a leitura desse arquivo, voc\u00ea de uma olhada nas issues iniciais do projeto, e siga os exemplos de como contribuir com o c\u00f3digo.","title":"Iniciando"},{"location":"CONTRIBUTING/#obtendo-ajuda","text":"A comunidade de contribui\u00e7\u00f5es da Tracy-TD possui um canal de comunica\u00e7\u00e3o no Discord , assim novos integrantes podem tirar suas d\u00favidas e interagir com outros membros.","title":"Obtendo ajuda"},{"location":"CONTRIBUTING/#comecando-a-contribuir","text":"Para voc\u00ea que \u00e9 iniciante, sugerimos que pegue uma issue simples, para come\u00e7ar a se familiarizar com o projeto, as issue para os iniciantes se encontram neste link (COLOCAR O LINK), essas issues possuem a Labels \"good first issue\".","title":"Come\u00e7ando a contribuir"},{"location":"CONTRIBUTING/#iniciando-o-desenvolvimento","text":"Para iniciar o desenvolvimento \u00e9 necess\u00e1rio criar uma branch, existe como padr\u00e3o, dois tipos de branchs, feature e bugfix: feature: Prefixo de branch para nova funcionalidade ou melhoria; Nova funcionalidade: Uma nova fun\u00e7\u00e3o para a API a qual ainda n\u00e3o existe; Melhoria: Melhoria de uma fun\u00e7\u00e3o j\u00e1 existente ou parte do c\u00f3digo. bugfix: Prefixo de branch que corrige algum bug em c\u00f3digo. Sabendo dos prefixos de cada tipo de issue, preencha o sufixo do nome da branch com \"/\" seguido do n\u00famero da Issue. Exemplo: \"feature/xxxx\", \"bugfix/yyyy\". Criando uma branch via terminal: - git checkout - b \\ - Esse comando cria a branch com o nome passado no par\u00e2metro (n\u00e3o utilizar os \"<>\") e ainda troca para branch atual de uso.","title":"Iniciando o desenvolvimento"},{"location":"CONTRIBUTING/#criando-issue","text":"Se voc\u00ea encontrou algum bug ou quer sugerir alguma funcionalidade, voc\u00ea pode criar uma issue nesse LINK (botar o link) Para criar uma nova Issue, voc\u00ea pode seguir os seguintes passos, todos os passos a seguir come\u00e7am ao acessar a aba de Issues , ou j\u00e1 no template de New issue do reposit\u00f3rio: Dentro do template de New issue, no input de \"Title\", escreva brevimente o que a nova issue deve fazer, e ent\u00e3o no input de \"Leave a comment\", fa\u00e7a uma descri\u00e7\u00e3o mais detalhada sobre como a issue deve ser executada/implementada. Ap\u00f3s as especifica\u00e7\u00f5es da nova issue, ao lado direito existe alguns complementos importantes: - Em \"Assignees\" voc\u00ea pode escolher a pessoa respons\u00e1vel para a execu\u00e7\u00e3o da issue, caso o objetivo seja apenas deixar a issue registrada, n\u00e3o precisa atribuir, caso queira pegar uma issue, siga para se\u00e7\u00e3o atribuindo uma issue . - Em \"Labels\" voc\u00ea define que tipo de feature e caracteristica essa issue possui, como \"bug\", para uma issue referente a um bug no sistema, \"documentation\" issue que mexe com algum arquivo refente a documenta\u00e7\u00e3o do projeto, \"enhancement\", para issue referente a uma nova feature ou melhoria para o sistema, existem varias labels e. Issue podem receber varias labels e n\u00e3o s\u00e3o obrigat\u00f3rias para a cria\u00e7\u00e3o de uma. Ap\u00f3s esses passos a sua issue est\u00e1 pronta para ser criada, clique em \"Submite new issue\" e receba a nova issue com um \"#\" seguido de um valor num\u00e9rico, um identificador para a issue, e este identificador ser\u00e1 utilizado no coment\u00e1rio do seu Pull Request para ser feito o link entre a issue e o Pull Request.","title":"Criando issue"},{"location":"CONTRIBUTING/#atribuindo-uma-issue","text":"Para atribuir uma issue, voc\u00ea precisa acessa a aba de Issues , ao selecionar uma issue, ela ser\u00e1 aberta e poder\u00e1 receber atribui\u00e7\u00e3o(\u00f5es) ao clicar em \"Assignees\", ent\u00e3o selecionar quem dever\u00e1 fazer parte do desenvolvimento dessa issue. Lembrando que em Assigness, n\u00e3o ser\u00e3o as mesmas pessoas que ir\u00e3o revisar o seu Pull Request .","title":"Atribuindo uma issue"},{"location":"CONTRIBUTING/#fazendo-pull-request","text":"Ao concluir a sua contribui\u00e7\u00e3o \u00e9 hora de fazer o famoso Pull Request, onde ele ser\u00e1 revisado pela comunidade e ent\u00e3o, se tudo estiver de acordo com as expectativas dos revisadores o Pull Request ser\u00e1 aceito. Mas para isso, \u00e9 preciso seguir alguns passos primeiro, \u00e9 preciso preparar os arquivos que ser\u00e3o adicionados para o commit e consequentemente para o Pull Request/Revis\u00e3o, com os seguintes passos no terminal: git add \"{nome do arquivo}\" ou git add . , que adiciona o arquivo menscionado ou todos os arquivos salvos e modificados ao Stage, tamb\u00e9m pode ser chamado de Index ou Staging Area: O Staging Area \u00e9 um lugar onde os arquivos est\u00e3o sendo preparados para o commit. git commit -m \"{mensagem do commit}\" , com esse comando voc\u00ea transfere seus arquivos para o diret\u00f3rio local do git com uma mensagem sobre o commit, muito importante que essa mensagem contenha informa\u00e7\u00f5es sobre as altera\u00e7\u00f5es feitas e referencie a issue associada a contribui\u00e7\u00e3o: A mensagem do commit deve conter uma refer\u00eancia a issue, essa refer\u00eancia \u00e9 feita atraves de # seguido do n\u00famero de identifica\u00e7\u00e3o da issue no github, seguido de uma breve descri\u00e7\u00e3o do que foi feito. git push , com o git push, os arquivos ser\u00e3o enviados para o reposit\u00f3rio da nuvem do github: \u00c9 possivel que pe\u00e7a suas credenciais, informe elas e continue o procedimento; Caso a branch ainda n\u00e3o exista no reposit\u00f3rio do github, ser\u00e1 exibido uma mensagem para no terminal para publicar a branch, copie a mensagem e execute para subir suas altera\u00e7\u00f5es; No reposit\u00f3rio do github do projeto, ao estar logado com as credenciais iguais as informadas, ser\u00e1 exibido uma mensagem informado que existe um Pull Request para ser solicitado...","title":"Fazendo Pull Request"},{"location":"CONTRIBUTING/#contribuindo-com-o-codigo","text":"Para contribui\u00e7\u00e3o de c\u00f3digo temos 3 categorias para uma issue: - Nova funcionalidade, s\u00e3o acressimos de novas fun\u00e7\u00f5es ou recursos que ainda n\u00e3o existem no projeto, e possui como titulo da branch \"feature\". - Melhoria, s\u00e3o mudna\u00e7as em fun\u00e7\u00f5es ou recursos que \u00e1 existem no projeto, possuindo o titulo de branch \"feature\". - Bug, os bugs s\u00e3o dividos em dois, cr\u00edticos e n\u00e3o cr\u00edticos, ambos possuiem o titulo de branch \"bugfix\": - Cr\u00edticos, afetam gravimente alguma funcionalidade importante do sistema, o que torna a aplica\u00e7\u00e3o inutilizavel ou de dificil acesso. - N\u00e3o cr\u00edticos, s\u00e3o os bugs que causam apenas um leve incomodo na aplica\u00e7\u00e3o, onde n\u00e3o chegam a causar tanto impacto na funcionalidade.","title":"Contribuindo com o c\u00f3digo"},{"location":"CONTRIBUTING/#contribuindo-com-a-documentacao","text":"A documenta\u00e7\u00e3o de um software sempre muda de acordo com as novas funcionalidades que s\u00e3o desenvolvidas, desta forma, atualiza\u00e7\u00f5es s\u00e3o necess\u00e1rias para que o software e documenta\u00e7\u00e3o estejam sempre alinhados, essa \u00e9 um tipo de contribui\u00e7\u00e3o importante para manter a integridade entre os desenvolvedores e quem faz uso da ferramenta. Veja a documenta\u00e7\u00e3o aqui.(COLOCAR LINK) Outros arquivos como o README, C\u00f3digo de condulta e o este guia de contribui\u00e7\u00f5es podem receber novas altera\u00e7\u00f5es se forem necess\u00e1rias, abra uma issue e comece a contribuir agora mesmo.","title":"Contribuindo com a documenta\u00e7\u00e3o"},{"location":"CONTRIBUTING/#como-criar-um-relatorio-de-bug","text":"","title":"Como criar um relat\u00f3rio de bug"},{"location":"CONTRIBUTING/#implementacao-dos-testes","text":"TODO isso aqui \u00e9 um md a parte que terar um link para ser acessado daqui","title":"Implementa\u00e7\u00e3o dos testes"},{"location":"TEST-GUIDE/","text":"Testes unit\u00e1rios com mock para as classes de servi\u00e7os Ser\u00e3o demonstradas neste guia de teste, as 4 fun\u00e7\u00f5es de um CRUD e exce\u00e7\u00e3o, para que assim, seja possivel que se tenha uma ideia basica de como continuar com a implementa\u00e7\u00e3o de testes. Um teste \u00e9 composto por 3 fases: prepara\u00e7\u00e3o, execu\u00e7\u00e3o e valida\u00e7\u00e3o. - Prepara\u00e7\u00e3o: nessa etapa \u00e9 criado todos os argumentos necess\u00e1rios e configura\u00e7\u00f5es para que o teste possa representar o mais pr\u00f3ximo do cenario real; - Execu\u00e7\u00e3o: aqui onde se utiliza os argumentos produzidos na prepara\u00e7\u00e3o e executamos o metodo do servi\u00e7o a qual queremos testar; - Valida\u00e7\u00e3o: a fase mais importante de um teste, onde ocorre todas as verifica\u00e7\u00f5es da execu\u00e7\u00e3o do teste e se ocorreu como esperado; Para testarmos um servi\u00e7o vamos come\u00e7ar criando a classe de teste, caso a classe de teste n\u00e3o exista. A nomeclatura da classe de teste deve seguir um padr\u00e3o \"{nome da classe do servi\u00e7o}\" + \"Test\", por exemplo: \"TechnicalDebtServiceTest\", o local em que esse arquivo deve est\u00e1 \u00e9 no path do projeto em \"src/test/java/org/{nome_do_projeto}\" dentro de um diret\u00f3rio que o servi\u00e7o fa\u00e7a parte, para o exemplo em quest\u00e3o o diret\u00f3rio \u00e9 \"technicalDebt\", resultando no seguinte path: \"src/test/java/org/tracy/technicaldebt\", logo ap\u00f3s adicionamos a anota\u00e7\u00e3o @Tag(\"Service\") e @ExtendWith(MockitoExtension.class) em cima do \"public class\". @Tag(\"Service\") @ExtendWith(MockitoExtension.class) public class TechnicalDebtServiceTest { } Agora precisamos pegar os atributos da classe de servi\u00e7o para a qual os testes devem ser feitos e passar como atributos da classe teste, os atributos que forem outros servi\u00e7os e reposit\u00f3rios, devem receber a anota\u00e7\u00e3o @Mock. @Tag(\"Service\") @ExtendWith(MockitoExtension.class) public class TechnicalDebtServiceTest { @Mock private ITAssetService assetService; @Mock private BusinessProcessService businessProcessService; @Mock private BusinessMetricService businessMetricService; ... } Ap\u00f3s todos os atributos necess\u00e1rios para a classe de servi\u00e7o estiverem \"mockados\" deve ser injetado todos os mocks em uma inst\u00e2ncia do servi\u00e7o, isso pode ser feito atraves da anota\u00e7\u00e3o @InjectMocks ou atrav\u00e9s de um metodo de constru\u00e7\u00e3o anotado por um @Beforeach, damos preferencia ao @InjectMocks. @Tag(\"Service\") @ExtendWith(MockitoExtension.class) public class TechnicalDebtServiceTest { @Mock private ITAssetService assetService; @Mock private BusinessProcessService businessProcessService; @Mock private BusinessMetricService businessMetricService; ... @Mock private BusinessCanvasService businessCanvasService; @InjectMocks private TechnicalDebtService technicalDebtService; } Com todos as depend\u00eancias injetadas no servi\u00e7o para ser testado, partimos para cria\u00e7\u00e3o do teste unit\u00e1rio, na mesma classe, iniciamos o m\u00e9todo de teste com uma nomeclatura a qual deve de forma mais clara possivel identificar a valida\u00e7\u00e3o do teste. Todos os testes devem ter como retorno o tipo void, e uma anota\u00e7\u00e3o obrigat\u00f3ria @Test e uma opcinal @DisplayName (pode haver outras anota\u00e7\u00f5es opcionais), a anota\u00e7\u00e3o @Test marca o metodo como teste, fazendo com que o testrunner execute os m\u00e9todos anotados, al\u00e9m de poder executar cada um isoladamente. J\u00e1 o @DisplayName d\u00e1 uma titulo ao teste, para que na interface seja visto com mais detalhes o que o teste se prop\u00f5em a fazer, nesta anota\u00e7\u00e3o voc\u00ea pode escrever em qualquer lingua, desde que fique claro e compat\u00edvel. Como primeiro exemplo, ser\u00e1 testado a cria\u00e7\u00e3o de uma TechnicalDebt, ent\u00e3o, para o nome do metodo de teste algo parecido com \"shouldSaveTechnicalDebt\", com o retorno void e duas anota\u00e7\u00f5es, no DisplayName evidenciando a valida\u00e7\u00e3o do teste: @Test @DisplayName(\"Deve salvar uma divida tecnica\") void shouldSaveTechnicalDebt() { } Agora vamos para a primeira etapa do teste, a prepara\u00e7\u00e3o, aqui vamos olhar para o fluxo metodo \"save\" do servi\u00e7o \"TechnicalDebtService\" e criar as entidades e configura\u00e7\u00f5es que precisaremos para a segunda e terceira etapa. No metodo save, vemos dois parametros \"TechnicalDebt\" e \"Feedback\", os quais precisamos ent\u00e3o cria-los na prepara\u00e7\u00e3o do teste, a primeira etapa. Ent\u00e3o, em uma breve analise notamos que precisamos mockar o retorno do saveAndFlush() do reposit\u00f3rio \"technicalDebtRepository\". Para o teste em quest\u00e3o \u00e9 necess\u00e1rio mockar outros comportamentos de outras classes (servi\u00e7os e reposit\u00f3rios), mas para esse guia n\u00e3o ficar extenso n\u00e3o ser\u00e3o detalhados. @Transactional public TechnicalDebt save(TechnicalDebt technicalDebt, Feedback feedback) { initializeLists(technicalDebt); if(technicalDebt.getBusinessPriority() == null){ technicalDebt.setBusinessPriority(BusinessPriorityValue.UNDEFINED.value); } if(technicalDebt.getIssue() != null && technicalDebt.getIssue().getAssignedTo() != null){ technicalDebt.setAssignedTo(technicalDebt.getAssignedTo()); //TODO aqui est\u00e1 pegando o mesmo valor e setando o mesmo valor? qual o sentido? } List<TechnicalDebtImpact> impactsToChange = technicalDebt.getTechnicalDebtImpacts(); technicalDebt.setTechnicalDebtImpacts(new LinkedList<>()); TechnicalDebt technicalDebtAfterSave = this.technicalDebtRepository.saveAndFlush(technicalDebt); persistTechImpacts(technicalDebt); updateTechnicalDebtImpacts(technicalDebtAfterSave, impactsToChange); updateAndSaveBusinessPriority(technicalDebtAfterSave, \"TD_CREATE\", feedback); this.technicalDebtRepository.flush(); return technicalDebtAfterSave; } Na primeira etapa criamos os objetos e configuramos os retornos mocks dos atributos anotados com @Mock atrav\u00e9s do metodo \"when()\" do Mockito seguido de um \".return()\" com o objeto simulado no retorno real do m\u00e9todo da classe mockada, mas primeiro, precisamos construir esses retornos, e para facilitar a contru\u00e7\u00e3o de tais objetos utilizamos os m\u00e9todos est\u00e1ticos, builders, para poupar tempo e linhas de c\u00f3digo. Na linha 148 o comportamento do reposit\u00f3rio \u00e9 simulado, utilizando o \"when()\", note que \u00e9 preciso especificar qual m\u00e9todo a classe mockada est\u00e1 chamando e passar como par\u00e2metro a classe que o m\u00e9todo espera, e no \".return()\", a simula\u00e7\u00e3o do retorno, o objeto technicalDebt. @Test @DisplayName(\"Deve salvar uma divida tecnica\") void shouldSaveTechnicalDebt() { ConfigItem configItemReturn = createConfigItem().id(1L).build(); TechnicalDebt technicalDebt = createTechnicalDebt().build(); Feedback feedback = createFeedBack().build(); PriorityCanvas priorityCanvas = createPriorityCanvas().build(); when(configItemService.findById(anyLong())).thenReturn(configItemReturn); when(technicalDebtRepository.saveAndFlush(any(TechnicalDebt.class))).thenReturn(technicalDebt); when(technicalDebtRepository.save(any(TechnicalDebt.class))).thenReturn(technicalDebt); when(priorityCanvasRepository.findAllByOrganizationId(anyLong())) .thenReturn(Collections.singletonList(priorityCanvas)); } Com as entidades criadas e retornos simulados como esperado, continuamos para a segunda etapa do teste, a execu\u00e7\u00e3o, bem simples, apenas chamamos o m\u00e9todo a qual queremos testar e passamos seus devidos par\u00e2metros. @Test @DisplayName(\"Deve salvar uma divida tecnica\") void shouldSaveTechnicalDebt() { ... when(configItemService.findById(anyLong())).thenReturn(configItemReturn); when(technicalDebtRepository.saveAndFlush(any(TechnicalDebt.class))).thenReturn(technicalDebt); when(technicalDebtRepository.save(any(TechnicalDebt.class))).thenReturn(technicalDebt); when(priorityCanvasRepository.findAllByOrganizationId(anyLong())) .thenReturn(Collections.singletonList(priorityCanvas)); technicalDebtService.save(technicalDebt, feedback); ArgumentCaptor<TechnicalDebt> technicalDebtArgumentCaptor = ArgumentCaptor.forClass(TechnicalDebt.class); ArgumentCaptor<PriorityLog> priorityLogArgumentCaptor = ArgumentCaptor.forClass(PriorityLog.class); Depois da prepara\u00e7\u00e3o e execu\u00e7\u00e3o, chegou a vez da valida\u00e7\u00e3o dos resultados, em alguns casos, \u00e9 preciso saber como o objeto chegou ao reposit\u00f3rio/servi\u00e7o, momento que o objeto \u00e9 passado por par\u00e2metro do m\u00e9todo, e para isso \u00e9 necess\u00e1rio a cria\u00e7\u00e3o de objetos do tipo ArgumentCaptor, ele \u00e9 capaz de capturar os objetos nos par\u00e2metros e \u00e9 usado em conjunto com o m\u00e9todo \"verify()\", o m\u00e9todo verify, verifica as ocorr\u00eancias das chamadas aos m\u00e9todos da classe que foram utilizados durante a execu\u00e7\u00e3o do teste, que por padr\u00e3o \u00e9 \"times(1)\", uma ocorr\u00eancia do m\u00e9todo da inst\u00e2ncia, o times \u00e9 o segundo par\u00e2metro do m\u00e9todo verify(), em seguida utilizasse o \".\" mas o m\u00e9todo que deseja verificar a ocorr\u00eancia, que para esse exemplo vamos focar no \"saveAndFlush()\", linha 158, que \u00e9 passado como parametro um ArgumentCaptor do tipo TechnicalDebt, que \u00e9 justamento a classe que chega para ser salva no reposit\u00f3rio. Com o m\u00e9todo \"capture()\" do ArgumentCaptor para capturar o valor e depois utilizamos o m\u00e9todo \"getValue()\" para pegar o valor capturado e armazenar em uma vari\u00e1vel, essa vari\u00e1vel ser\u00e1 utilizado para verifica\u00e7\u00e3o dos campos. ArgumentCaptor<TechnicalDebt> technicalDebtArgumentCaptor = ArgumentCaptor.forClass(TechnicalDebt.class); ArgumentCaptor<PriorityLog> priorityLogArgumentCaptor = ArgumentCaptor.forClass(PriorityLog.class); verify(technicalDebtRepository).saveAndFlush(technicalDebtArgumentCaptor.capture()); TechnicalDebt beforeSaveTechnicalDebt = technicalDebtArgumentCaptor.getValue(); verify(impactService).saveAll(any()); verify(technicalDebtRepository).save(technicalDebtArgumentCaptor.capture()); TechnicalDebt afterSaveTechnicalDebt = technicalDebtArgumentCaptor.getValue(); verify(logRepository).save(priorityLogArgumentCaptor.capture()); PriorityLog priorityLog = priorityLogArgumentCaptor.getValue(); A verifica\u00e7\u00e3o dos campos \u00e9 feita atrav\u00e9s dos assertions, aqui se compara os valores atuais dos valores esperados, dessa maneira validando campo a campo, importante que todos os campos sejam validados, pois, durante o fluxo \u00e9 poss\u00edvel que algum valor seja alterado, e essa altera\u00e7\u00e3o possa ser parte do fluxo ou um bug gerado, \u00e9 aqui que est\u00e1 a import\u00e2ncia do teste unit\u00e1rio, ele garante que para aquele fluxo o comportamento seja o esperado. @Test @DisplayName(\"Deve salvar uma divida tecnica\") void shouldSaveTechnicalDebt() { ... verify(technicalDebtRepository).saveAndFlush(technicalDebtArgumentCaptor.capture()); TechnicalDebt beforeSaveTechnicalDebt = technicalDebtArgumentCaptor.getValue(); verify(impactService).saveAll(any()); verify(technicalDebtRepository).save(technicalDebtArgumentCaptor.capture()); TechnicalDebt afterSaveTechnicalDebt = technicalDebtArgumentCaptor.getValue(); verify(logRepository).save(priorityLogArgumentCaptor.capture()); PriorityLog priorityLog = priorityLogArgumentCaptor.getValue(); assertAll(\"beforeSaveTechnicalDebt\", () -> assertThat(beforeSaveTechnicalDebt.getName(), is(technicalDebt.getName())), () -> assertThat(beforeSaveTechnicalDebt.getDescription(), is(technicalDebt.getDescription())), () -> assertThat(beforeSaveTechnicalDebt.getBusinessPriority(), is(technicalDebt.getBusinessPriority())), () -> assertThat(beforeSaveTechnicalDebt.getTechnicalPriority(), is(technicalDebt.getTechnicalPriority())), () -> assertThat(beforeSaveTechnicalDebt.getCheckedByUser(), is(technicalDebt.getCheckedByUser())), () -> assertThat(beforeSaveTechnicalDebt.getEnabled(), is(technicalDebt.getEnabled())), () -> assertThat(beforeSaveTechnicalDebt.getType(), is(technicalDebt.getType())) ); assertAll(\"afterSaveTechnicalDebt\", () -> assertThat(afterSaveTechnicalDebt.getTechnicalPriority(), is(technicalDebt.getTechnicalPriority())), () -> assertThat(afterSaveTechnicalDebt.getName(), is(technicalDebt.getName())), () -> assertThat(afterSaveTechnicalDebt.getDescription(), is(technicalDebt.getDescription())), () -> assertThat(afterSaveTechnicalDebt.getBusinessPriority(), is(technicalDebt.getBusinessPriority())), () -> assertThat(afterSaveTechnicalDebt.getTechnicalPriority(), is(technicalDebt.getTechnicalPriority())), () -> assertThat(afterSaveTechnicalDebt.getCheckedByUser(), is(technicalDebt.getCheckedByUser())), () -> assertThat(afterSaveTechnicalDebt.getEnabled(), is(technicalDebt.getEnabled())), () -> assertThat(afterSaveTechnicalDebt.getType(), is(technicalDebt.getType())) ); assertAll(\"priorityLog\", () -> assertThat(priorityLog.getTrigger(), is(\"TD_CREATE\")), () -> assertThat(priorityLog.getTdType(), is(\"TechnicalDebtType Name\")), () -> assertThat(priorityLog.getOldBusinessPriority(), is(1000)), () -> assertThat(priorityLog.getNewBusinessPriority(), is(100)), () -> assertThat(priorityLog.getOldTechnicalPriority(), is(1000)), () -> assertThat(priorityLog.getNewTechnicalPriority(), is(1000)), () -> assertThat(priorityLog.getComment(), is(\"FeedBack Comment\")), () -> assertFalse(priorityLog.getPrioritizedByImpact()), () -> assertFalse(priorityLog.getPrioritizedByEffort()), () -> assertFalse(priorityLog.getPrioritizedByType()), () -> assertFalse(priorityLog.getPrioritizedByAge()) ); } Builders s\u00e3o os metodos que fazem inst\u00e2ncia da classe e que voc\u00ea pode alterar os campos enquanto chama o m\u00e9todo, como na linha 142 onde o campo \"id\" est\u00e1 sendo setado com o valor 1L. Os builders ficam no path referente aos testes, em: \"src/test/java/org/tracy/builders\". Builders podem possuir outros builders para facilitar a sua constru\u00e7\u00e3o, mas cuidado para n\u00e3o gerar recurs\u00e3o entre eles. public class ConfigItemBuilder { public static ConfigItem.Builder createConfigItem() { return ConfigItem.builder() .id(1L) .name(\"ConfigItem Name\") .description(\"ConfigItem Description\") .type(createConfigItemType().build()) .status(Status.OPERATIONAL) .children(Collections.singletonList(createConfigItemChildren().build())) .organization(createOrganization().build()) .affectedITAssets(Collections.singletonList(createITAsset().build())) .teams(Collections.singletonList(createTeam().build())); } }","title":"TEST GUIDE"},{"location":"TEST-GUIDE/#testes-unitarios-com-mock-para-as-classes-de-servicos","text":"Ser\u00e3o demonstradas neste guia de teste, as 4 fun\u00e7\u00f5es de um CRUD e exce\u00e7\u00e3o, para que assim, seja possivel que se tenha uma ideia basica de como continuar com a implementa\u00e7\u00e3o de testes. Um teste \u00e9 composto por 3 fases: prepara\u00e7\u00e3o, execu\u00e7\u00e3o e valida\u00e7\u00e3o. - Prepara\u00e7\u00e3o: nessa etapa \u00e9 criado todos os argumentos necess\u00e1rios e configura\u00e7\u00f5es para que o teste possa representar o mais pr\u00f3ximo do cenario real; - Execu\u00e7\u00e3o: aqui onde se utiliza os argumentos produzidos na prepara\u00e7\u00e3o e executamos o metodo do servi\u00e7o a qual queremos testar; - Valida\u00e7\u00e3o: a fase mais importante de um teste, onde ocorre todas as verifica\u00e7\u00f5es da execu\u00e7\u00e3o do teste e se ocorreu como esperado; Para testarmos um servi\u00e7o vamos come\u00e7ar criando a classe de teste, caso a classe de teste n\u00e3o exista. A nomeclatura da classe de teste deve seguir um padr\u00e3o \"{nome da classe do servi\u00e7o}\" + \"Test\", por exemplo: \"TechnicalDebtServiceTest\", o local em que esse arquivo deve est\u00e1 \u00e9 no path do projeto em \"src/test/java/org/{nome_do_projeto}\" dentro de um diret\u00f3rio que o servi\u00e7o fa\u00e7a parte, para o exemplo em quest\u00e3o o diret\u00f3rio \u00e9 \"technicalDebt\", resultando no seguinte path: \"src/test/java/org/tracy/technicaldebt\", logo ap\u00f3s adicionamos a anota\u00e7\u00e3o @Tag(\"Service\") e @ExtendWith(MockitoExtension.class) em cima do \"public class\". @Tag(\"Service\") @ExtendWith(MockitoExtension.class) public class TechnicalDebtServiceTest { } Agora precisamos pegar os atributos da classe de servi\u00e7o para a qual os testes devem ser feitos e passar como atributos da classe teste, os atributos que forem outros servi\u00e7os e reposit\u00f3rios, devem receber a anota\u00e7\u00e3o @Mock. @Tag(\"Service\") @ExtendWith(MockitoExtension.class) public class TechnicalDebtServiceTest { @Mock private ITAssetService assetService; @Mock private BusinessProcessService businessProcessService; @Mock private BusinessMetricService businessMetricService; ... } Ap\u00f3s todos os atributos necess\u00e1rios para a classe de servi\u00e7o estiverem \"mockados\" deve ser injetado todos os mocks em uma inst\u00e2ncia do servi\u00e7o, isso pode ser feito atraves da anota\u00e7\u00e3o @InjectMocks ou atrav\u00e9s de um metodo de constru\u00e7\u00e3o anotado por um @Beforeach, damos preferencia ao @InjectMocks. @Tag(\"Service\") @ExtendWith(MockitoExtension.class) public class TechnicalDebtServiceTest { @Mock private ITAssetService assetService; @Mock private BusinessProcessService businessProcessService; @Mock private BusinessMetricService businessMetricService; ... @Mock private BusinessCanvasService businessCanvasService; @InjectMocks private TechnicalDebtService technicalDebtService; } Com todos as depend\u00eancias injetadas no servi\u00e7o para ser testado, partimos para cria\u00e7\u00e3o do teste unit\u00e1rio, na mesma classe, iniciamos o m\u00e9todo de teste com uma nomeclatura a qual deve de forma mais clara possivel identificar a valida\u00e7\u00e3o do teste. Todos os testes devem ter como retorno o tipo void, e uma anota\u00e7\u00e3o obrigat\u00f3ria @Test e uma opcinal @DisplayName (pode haver outras anota\u00e7\u00f5es opcionais), a anota\u00e7\u00e3o @Test marca o metodo como teste, fazendo com que o testrunner execute os m\u00e9todos anotados, al\u00e9m de poder executar cada um isoladamente. J\u00e1 o @DisplayName d\u00e1 uma titulo ao teste, para que na interface seja visto com mais detalhes o que o teste se prop\u00f5em a fazer, nesta anota\u00e7\u00e3o voc\u00ea pode escrever em qualquer lingua, desde que fique claro e compat\u00edvel. Como primeiro exemplo, ser\u00e1 testado a cria\u00e7\u00e3o de uma TechnicalDebt, ent\u00e3o, para o nome do metodo de teste algo parecido com \"shouldSaveTechnicalDebt\", com o retorno void e duas anota\u00e7\u00f5es, no DisplayName evidenciando a valida\u00e7\u00e3o do teste: @Test @DisplayName(\"Deve salvar uma divida tecnica\") void shouldSaveTechnicalDebt() { } Agora vamos para a primeira etapa do teste, a prepara\u00e7\u00e3o, aqui vamos olhar para o fluxo metodo \"save\" do servi\u00e7o \"TechnicalDebtService\" e criar as entidades e configura\u00e7\u00f5es que precisaremos para a segunda e terceira etapa. No metodo save, vemos dois parametros \"TechnicalDebt\" e \"Feedback\", os quais precisamos ent\u00e3o cria-los na prepara\u00e7\u00e3o do teste, a primeira etapa. Ent\u00e3o, em uma breve analise notamos que precisamos mockar o retorno do saveAndFlush() do reposit\u00f3rio \"technicalDebtRepository\". Para o teste em quest\u00e3o \u00e9 necess\u00e1rio mockar outros comportamentos de outras classes (servi\u00e7os e reposit\u00f3rios), mas para esse guia n\u00e3o ficar extenso n\u00e3o ser\u00e3o detalhados. @Transactional public TechnicalDebt save(TechnicalDebt technicalDebt, Feedback feedback) { initializeLists(technicalDebt); if(technicalDebt.getBusinessPriority() == null){ technicalDebt.setBusinessPriority(BusinessPriorityValue.UNDEFINED.value); } if(technicalDebt.getIssue() != null && technicalDebt.getIssue().getAssignedTo() != null){ technicalDebt.setAssignedTo(technicalDebt.getAssignedTo()); //TODO aqui est\u00e1 pegando o mesmo valor e setando o mesmo valor? qual o sentido? } List<TechnicalDebtImpact> impactsToChange = technicalDebt.getTechnicalDebtImpacts(); technicalDebt.setTechnicalDebtImpacts(new LinkedList<>()); TechnicalDebt technicalDebtAfterSave = this.technicalDebtRepository.saveAndFlush(technicalDebt); persistTechImpacts(technicalDebt); updateTechnicalDebtImpacts(technicalDebtAfterSave, impactsToChange); updateAndSaveBusinessPriority(technicalDebtAfterSave, \"TD_CREATE\", feedback); this.technicalDebtRepository.flush(); return technicalDebtAfterSave; } Na primeira etapa criamos os objetos e configuramos os retornos mocks dos atributos anotados com @Mock atrav\u00e9s do metodo \"when()\" do Mockito seguido de um \".return()\" com o objeto simulado no retorno real do m\u00e9todo da classe mockada, mas primeiro, precisamos construir esses retornos, e para facilitar a contru\u00e7\u00e3o de tais objetos utilizamos os m\u00e9todos est\u00e1ticos, builders, para poupar tempo e linhas de c\u00f3digo. Na linha 148 o comportamento do reposit\u00f3rio \u00e9 simulado, utilizando o \"when()\", note que \u00e9 preciso especificar qual m\u00e9todo a classe mockada est\u00e1 chamando e passar como par\u00e2metro a classe que o m\u00e9todo espera, e no \".return()\", a simula\u00e7\u00e3o do retorno, o objeto technicalDebt. @Test @DisplayName(\"Deve salvar uma divida tecnica\") void shouldSaveTechnicalDebt() { ConfigItem configItemReturn = createConfigItem().id(1L).build(); TechnicalDebt technicalDebt = createTechnicalDebt().build(); Feedback feedback = createFeedBack().build(); PriorityCanvas priorityCanvas = createPriorityCanvas().build(); when(configItemService.findById(anyLong())).thenReturn(configItemReturn); when(technicalDebtRepository.saveAndFlush(any(TechnicalDebt.class))).thenReturn(technicalDebt); when(technicalDebtRepository.save(any(TechnicalDebt.class))).thenReturn(technicalDebt); when(priorityCanvasRepository.findAllByOrganizationId(anyLong())) .thenReturn(Collections.singletonList(priorityCanvas)); } Com as entidades criadas e retornos simulados como esperado, continuamos para a segunda etapa do teste, a execu\u00e7\u00e3o, bem simples, apenas chamamos o m\u00e9todo a qual queremos testar e passamos seus devidos par\u00e2metros. @Test @DisplayName(\"Deve salvar uma divida tecnica\") void shouldSaveTechnicalDebt() { ... when(configItemService.findById(anyLong())).thenReturn(configItemReturn); when(technicalDebtRepository.saveAndFlush(any(TechnicalDebt.class))).thenReturn(technicalDebt); when(technicalDebtRepository.save(any(TechnicalDebt.class))).thenReturn(technicalDebt); when(priorityCanvasRepository.findAllByOrganizationId(anyLong())) .thenReturn(Collections.singletonList(priorityCanvas)); technicalDebtService.save(technicalDebt, feedback); ArgumentCaptor<TechnicalDebt> technicalDebtArgumentCaptor = ArgumentCaptor.forClass(TechnicalDebt.class); ArgumentCaptor<PriorityLog> priorityLogArgumentCaptor = ArgumentCaptor.forClass(PriorityLog.class); Depois da prepara\u00e7\u00e3o e execu\u00e7\u00e3o, chegou a vez da valida\u00e7\u00e3o dos resultados, em alguns casos, \u00e9 preciso saber como o objeto chegou ao reposit\u00f3rio/servi\u00e7o, momento que o objeto \u00e9 passado por par\u00e2metro do m\u00e9todo, e para isso \u00e9 necess\u00e1rio a cria\u00e7\u00e3o de objetos do tipo ArgumentCaptor, ele \u00e9 capaz de capturar os objetos nos par\u00e2metros e \u00e9 usado em conjunto com o m\u00e9todo \"verify()\", o m\u00e9todo verify, verifica as ocorr\u00eancias das chamadas aos m\u00e9todos da classe que foram utilizados durante a execu\u00e7\u00e3o do teste, que por padr\u00e3o \u00e9 \"times(1)\", uma ocorr\u00eancia do m\u00e9todo da inst\u00e2ncia, o times \u00e9 o segundo par\u00e2metro do m\u00e9todo verify(), em seguida utilizasse o \".\" mas o m\u00e9todo que deseja verificar a ocorr\u00eancia, que para esse exemplo vamos focar no \"saveAndFlush()\", linha 158, que \u00e9 passado como parametro um ArgumentCaptor do tipo TechnicalDebt, que \u00e9 justamento a classe que chega para ser salva no reposit\u00f3rio. Com o m\u00e9todo \"capture()\" do ArgumentCaptor para capturar o valor e depois utilizamos o m\u00e9todo \"getValue()\" para pegar o valor capturado e armazenar em uma vari\u00e1vel, essa vari\u00e1vel ser\u00e1 utilizado para verifica\u00e7\u00e3o dos campos. ArgumentCaptor<TechnicalDebt> technicalDebtArgumentCaptor = ArgumentCaptor.forClass(TechnicalDebt.class); ArgumentCaptor<PriorityLog> priorityLogArgumentCaptor = ArgumentCaptor.forClass(PriorityLog.class); verify(technicalDebtRepository).saveAndFlush(technicalDebtArgumentCaptor.capture()); TechnicalDebt beforeSaveTechnicalDebt = technicalDebtArgumentCaptor.getValue(); verify(impactService).saveAll(any()); verify(technicalDebtRepository).save(technicalDebtArgumentCaptor.capture()); TechnicalDebt afterSaveTechnicalDebt = technicalDebtArgumentCaptor.getValue(); verify(logRepository).save(priorityLogArgumentCaptor.capture()); PriorityLog priorityLog = priorityLogArgumentCaptor.getValue(); A verifica\u00e7\u00e3o dos campos \u00e9 feita atrav\u00e9s dos assertions, aqui se compara os valores atuais dos valores esperados, dessa maneira validando campo a campo, importante que todos os campos sejam validados, pois, durante o fluxo \u00e9 poss\u00edvel que algum valor seja alterado, e essa altera\u00e7\u00e3o possa ser parte do fluxo ou um bug gerado, \u00e9 aqui que est\u00e1 a import\u00e2ncia do teste unit\u00e1rio, ele garante que para aquele fluxo o comportamento seja o esperado. @Test @DisplayName(\"Deve salvar uma divida tecnica\") void shouldSaveTechnicalDebt() { ... verify(technicalDebtRepository).saveAndFlush(technicalDebtArgumentCaptor.capture()); TechnicalDebt beforeSaveTechnicalDebt = technicalDebtArgumentCaptor.getValue(); verify(impactService).saveAll(any()); verify(technicalDebtRepository).save(technicalDebtArgumentCaptor.capture()); TechnicalDebt afterSaveTechnicalDebt = technicalDebtArgumentCaptor.getValue(); verify(logRepository).save(priorityLogArgumentCaptor.capture()); PriorityLog priorityLog = priorityLogArgumentCaptor.getValue(); assertAll(\"beforeSaveTechnicalDebt\", () -> assertThat(beforeSaveTechnicalDebt.getName(), is(technicalDebt.getName())), () -> assertThat(beforeSaveTechnicalDebt.getDescription(), is(technicalDebt.getDescription())), () -> assertThat(beforeSaveTechnicalDebt.getBusinessPriority(), is(technicalDebt.getBusinessPriority())), () -> assertThat(beforeSaveTechnicalDebt.getTechnicalPriority(), is(technicalDebt.getTechnicalPriority())), () -> assertThat(beforeSaveTechnicalDebt.getCheckedByUser(), is(technicalDebt.getCheckedByUser())), () -> assertThat(beforeSaveTechnicalDebt.getEnabled(), is(technicalDebt.getEnabled())), () -> assertThat(beforeSaveTechnicalDebt.getType(), is(technicalDebt.getType())) ); assertAll(\"afterSaveTechnicalDebt\", () -> assertThat(afterSaveTechnicalDebt.getTechnicalPriority(), is(technicalDebt.getTechnicalPriority())), () -> assertThat(afterSaveTechnicalDebt.getName(), is(technicalDebt.getName())), () -> assertThat(afterSaveTechnicalDebt.getDescription(), is(technicalDebt.getDescription())), () -> assertThat(afterSaveTechnicalDebt.getBusinessPriority(), is(technicalDebt.getBusinessPriority())), () -> assertThat(afterSaveTechnicalDebt.getTechnicalPriority(), is(technicalDebt.getTechnicalPriority())), () -> assertThat(afterSaveTechnicalDebt.getCheckedByUser(), is(technicalDebt.getCheckedByUser())), () -> assertThat(afterSaveTechnicalDebt.getEnabled(), is(technicalDebt.getEnabled())), () -> assertThat(afterSaveTechnicalDebt.getType(), is(technicalDebt.getType())) ); assertAll(\"priorityLog\", () -> assertThat(priorityLog.getTrigger(), is(\"TD_CREATE\")), () -> assertThat(priorityLog.getTdType(), is(\"TechnicalDebtType Name\")), () -> assertThat(priorityLog.getOldBusinessPriority(), is(1000)), () -> assertThat(priorityLog.getNewBusinessPriority(), is(100)), () -> assertThat(priorityLog.getOldTechnicalPriority(), is(1000)), () -> assertThat(priorityLog.getNewTechnicalPriority(), is(1000)), () -> assertThat(priorityLog.getComment(), is(\"FeedBack Comment\")), () -> assertFalse(priorityLog.getPrioritizedByImpact()), () -> assertFalse(priorityLog.getPrioritizedByEffort()), () -> assertFalse(priorityLog.getPrioritizedByType()), () -> assertFalse(priorityLog.getPrioritizedByAge()) ); } Builders s\u00e3o os metodos que fazem inst\u00e2ncia da classe e que voc\u00ea pode alterar os campos enquanto chama o m\u00e9todo, como na linha 142 onde o campo \"id\" est\u00e1 sendo setado com o valor 1L. Os builders ficam no path referente aos testes, em: \"src/test/java/org/tracy/builders\". Builders podem possuir outros builders para facilitar a sua constru\u00e7\u00e3o, mas cuidado para n\u00e3o gerar recurs\u00e3o entre eles. public class ConfigItemBuilder { public static ConfigItem.Builder createConfigItem() { return ConfigItem.builder() .id(1L) .name(\"ConfigItem Name\") .description(\"ConfigItem Description\") .type(createConfigItemType().build()) .status(Status.OPERATIONAL) .children(Collections.singletonList(createConfigItemChildren().build())) .organization(createOrganization().build()) .affectedITAssets(Collections.singletonList(createITAsset().build())) .teams(Collections.singletonList(createTeam().build())); } }","title":"Testes unit\u00e1rios com mock para as classes de servi\u00e7os"},{"location":"dev_process/","text":"Development Process Sprint Planning Select issue New branch Think! Code! Pull Request Code / PR review Merge! Technical Discussion Read / update architecture model Tracy-TD architecture","title":"Development Process"},{"location":"dev_process/#development-process","text":"Sprint Planning Select issue New branch Think! Code! Pull Request Code / PR review Merge! Technical Discussion Read / update architecture model Tracy-TD architecture","title":"Development Process"},{"location":"esboco/","text":"Esbo\u00e7o de regras de Tracy Este documento \u00e9 um rascunho. As regras migrar\u00e3o para a documenta\u00e7\u00e3o oficial em breve. Integra\u00e7\u00e3o com o Jira. Ciclo de vida O Jira envia um push para o endpoint de Tracy a cada altera\u00e7\u00e3o nas issues do projeto. TODO: Informar a configura\u00e7\u00e3o do endpoint (em que eventos o endpoint deve ser chamado?) issueJira \u00e9 uma issue no Jira. Quando o campo customizado \"Technical Debt\" \u00e9 marcado com valor sim : Tracy receber\u00e1 o push e criar\u00e1 uma nova issue, que ser\u00e1 exibida na lista de issues. O usu\u00e1rio pode importar esta issue em uma nova d\u00edvida t\u00e9cnica. a nova d\u00edvida t\u00e9cnica est\u00e1 relacionada \u00e0 issue da qual foi importada. Tracy monitorar\u00e1 as mudan\u00e7as de estado desta issue e atualizar\u00e1 o estado de Tracy. Quando a issueJira, muda de estado, a d\u00edvida tamb\u00e9m muda de estado. TODO: informar a equival\u00eancia de estados entre as issues do Jira e das d\u00edvidas em Tracy. Quando uma issueJira \u00e9 apagada, se uma d\u00edvida j\u00e1 tiver sido criada a partir desta issue, a rela\u00e7\u00e3o da d\u00edvida com esta issue \u00e9 desfeita, MAS A D\u00cdVIDA, EM TRACY, N\u00c3O \u00c9 APAGADA! O ID da issueJira que est\u00e1 registrada na d\u00edvida \u00e9 apagada. Criar um","title":"Esbo\u00e7o de regras de Tracy"},{"location":"esboco/#esboco-de-regras-de-tracy","text":"Este documento \u00e9 um rascunho. As regras migrar\u00e3o para a documenta\u00e7\u00e3o oficial em breve.","title":"Esbo\u00e7o de regras de Tracy"},{"location":"esboco/#integracao-com-o-jira","text":"","title":"Integra\u00e7\u00e3o com o Jira."},{"location":"esboco/#ciclo-de-vida","text":"O Jira envia um push para o endpoint de Tracy a cada altera\u00e7\u00e3o nas issues do projeto. TODO: Informar a configura\u00e7\u00e3o do endpoint (em que eventos o endpoint deve ser chamado?) issueJira \u00e9 uma issue no Jira. Quando o campo customizado \"Technical Debt\" \u00e9 marcado com valor sim : Tracy receber\u00e1 o push e criar\u00e1 uma nova issue, que ser\u00e1 exibida na lista de issues. O usu\u00e1rio pode importar esta issue em uma nova d\u00edvida t\u00e9cnica. a nova d\u00edvida t\u00e9cnica est\u00e1 relacionada \u00e0 issue da qual foi importada. Tracy monitorar\u00e1 as mudan\u00e7as de estado desta issue e atualizar\u00e1 o estado de Tracy. Quando a issueJira, muda de estado, a d\u00edvida tamb\u00e9m muda de estado. TODO: informar a equival\u00eancia de estados entre as issues do Jira e das d\u00edvidas em Tracy. Quando uma issueJira \u00e9 apagada, se uma d\u00edvida j\u00e1 tiver sido criada a partir desta issue, a rela\u00e7\u00e3o da d\u00edvida com esta issue \u00e9 desfeita, MAS A D\u00cdVIDA, EM TRACY, N\u00c3O \u00c9 APAGADA! O ID da issueJira que est\u00e1 registrada na d\u00edvida \u00e9 apagada. Criar um","title":"Ciclo de vida"},{"location":"architecture/architecture/","text":"Arquitetura de Tracy-TD Current C4Model","title":"Arquitetura de Tracy-TD"},{"location":"architecture/architecture/#arquitetura-de-tracy-td","text":"Current C4Model","title":"Arquitetura de Tracy-TD"},{"location":"config/tracy-api-installation/","text":"Instala\u00e7\u00e3o - Tracy API Requisitos Para construir e executar a aplica\u00e7\u00e3o, voc\u00ea precisa de: Java Jre 8 Java JDK 11 PostgresSQL 11.5 Git Intellij IDE (Para uso com a parte de back end) Vs Code IDE (Se desejar usar na parte de front end. Caso contr\u00e1rio, o intelijj pode ser usado tamb\u00e9m) Maven (Baixe o arquivo Bynary.zip) CMD ou Windows Powershell Tutorial de instala\u00e7\u00e3o Tenha certeza que voc\u00ea j\u00e1 instalou todos os requisitos e, depois disso, siga os passos abaixo. Primeiro Passo: Backend Clonar os reposit\u00f3rios (Em caso de problemas usando o git bash, tentar pelo terminal cmd). Execute mvn clean install Criar o banco de dados no postgres nomeado tracytd Abrir o c\u00f3digo da api no Intellij. Dentro dos arquivos da api rest, criar um arquivo nomeado application-dev.yml (Caminho src > main > resources) Colar dentro do arquivo o seguinte c\u00f3digo: spring: datasource: url: jdbc:postgresql://localhost:5432/tracytd username: postgres password: tuasenha (substituir pela senha do postgres) Executar o comando mvn clean install no terminal do intellij. No intellij, ir at\u00e9 o menu Add Configuration, adicionar uma nova configura\u00e7\u00e3o (sinal + no canto superior esquerdo), selecionando a op\u00e7\u00e3o \"application\" No menu seguinte, complete os campos com essas instru\u00e7\u00f5es: name: \"tracy-api\" main class: procure a classe \"tracy application\" No campo \"Modify options\", escolha a op\u00e7\u00e3o \"Add vm options\", e no campo com o mesmo nome, cole o seguinte c\u00f3digo: -Dspring.profiles.active=dev Depois disso, clique em aplicar e ok. Se o campo \"Add configuration\" n\u00e3o mudar automaticamente, mude ele para a nova configura\u00e7\u00e3o. Rode o projeto! Segundo passo: Front End Clone o reposit\u00f3rio tracy-front. (Em caso de problemas com a funcionalidade do git bash voc\u00ea pode usar o cmd para fazer isso) Abra o projeto com o Vs Code e execute o comando npm i . Isso vai levar alguns minutos para executar. Ap\u00f3s o t\u00e9rmino, execute o comando ng s . Isso vai demorar um pouco mais. Depois que terminar, abra seu navegador e v\u00e1 para \"localhost: 4200\" Coloque o login \"admin@tracytd.org\", e a senha \"rootadmin\" Est\u00e1 pronto! Como conseguir ajuda? Voc\u00ea dever\u00e1 acessar o canal do Discord , onde ter\u00e1 acesso aos desenvolvedores trabalhando no projeto, assim como outras pessoas que est\u00e3o usando Tracy em suas empresas. Gerenciamento de contribui\u00e7\u00f5es O projeto tem um conselho de gest\u00e3o do que deve ou n\u00e3o ser priorizado. Esse conjunto de desenvolvedores \u00e9 formado por pessoas com experi\u00eancia no c\u00f3digo e no produto. Com o tempo, voc\u00ea tamb\u00e9m poder\u00e1 ajudar ingressando no conselho de administra\u00e7\u00e3o. Processo de desenvolvimento do projeto Registro de uma edi\u00e7\u00e3o (issue); Once registered, the issue can receive comments from other people, to detail and improve the description of the new enhancement request, new feature or bug to be solved. Anyone can take up an open issue and implement their solution. Uma vez registrada, a edi\u00e7\u00e3o pode receber coment\u00e1rios de outras pessoas, para detalhar e melhorar a descri\u00e7\u00e3o da nova solicita\u00e7\u00e3o de aprimoramento, novo recurso ou bug para ser resolvido. Qualquer um pode assumir um problema aberto e implementar sua solu\u00e7\u00e3o. Atribui\u00e7\u00e3o de uma Edi\u00e7\u00e3o ; In Issues you will have the entire backlog of the project, and by clicking on an issue, you can assign it, in \"Assigness\". So, it will be your development responsibility. follow the guidelines on how to create a branch and make a pull request. Em edi\u00e7\u00f5es voc\u00ea ter\u00e1 todo os registros acumulados do projeto e, clicando em uma edi\u00e7\u00e3o, voc\u00ea pode atribuir ela em \"Atribuir\". Ent\u00e3o, ela ser\u00e1 sua responsabilidade de desenvolvimento. Siga as orienta\u00e7\u00f5es sobre como criar uma branch e fazer uma solicita\u00e7\u00e3o. (Pull request). Criando branch; To start development it is necessary to create a branch. There are, by default, three types of branches: hot, feat and bugfix: - hot -> hotfix: Branch prefix for quick and small code change; - feat -> feature: Branch prefix for new feature or improvement; - bugfix -> Branch prefix that fixes some bug in code. Knowing the prefixes for each issue type, fill in the branch name suffix with \"/#\", followed by the Issue number. Example: \"hot/#xxxx\", \"feat/#yyyy\", \"bugfix/#zzzz\". Para come\u00e7ar o desenvolvimento \u00e9 necess\u00e1rio criar uma branch. Aqui est\u00e3o, por padr\u00e3o, tr\u00eas tipos de branch: hot, feat e bugfix: - hot -> hotfix: Prefico de branch para pequenas e r\u00e1pidas mudan\u00e3s de c\u00f3digo. - feat -> feature: Prefixo de branch para nova funcionalidade ou aprimoramento. - bugfix -> Prefixo de branch que conserta algum tipo de bug no c\u00f3digo. Conhecendo os prefixos para cada tipo de edi\u00e7\u00e3o, complete o sufixo do nome da branch com \"/#\", seguido do n\u00famero da edi\u00e7\u00e3o. Exemplo: \"hot/#xxxx\", \"feat/#yyyy\", \"bugfix/#zzzz\". Fazendo Pull Request; Ap\u00f3s implementar sua solu\u00e7\u00e3o \u00e9 hora de fazer o Pull Request...","title":"Instala\u00e7\u00e3o - Tracy API"},{"location":"config/tracy-api-installation/#instalacao-tracy-api","text":"","title":"Instala\u00e7\u00e3o - Tracy API"},{"location":"config/tracy-api-installation/#requisitos","text":"Para construir e executar a aplica\u00e7\u00e3o, voc\u00ea precisa de: Java Jre 8 Java JDK 11 PostgresSQL 11.5 Git Intellij IDE (Para uso com a parte de back end) Vs Code IDE (Se desejar usar na parte de front end. Caso contr\u00e1rio, o intelijj pode ser usado tamb\u00e9m) Maven (Baixe o arquivo Bynary.zip) CMD ou Windows Powershell","title":"Requisitos"},{"location":"config/tracy-api-installation/#tutorial-de-instalacao","text":"Tenha certeza que voc\u00ea j\u00e1 instalou todos os requisitos e, depois disso, siga os passos abaixo.","title":"Tutorial de instala\u00e7\u00e3o"},{"location":"config/tracy-api-installation/#primeiro-passo-backend","text":"Clonar os reposit\u00f3rios (Em caso de problemas usando o git bash, tentar pelo terminal cmd). Execute mvn clean install Criar o banco de dados no postgres nomeado tracytd Abrir o c\u00f3digo da api no Intellij. Dentro dos arquivos da api rest, criar um arquivo nomeado application-dev.yml (Caminho src > main > resources) Colar dentro do arquivo o seguinte c\u00f3digo: spring: datasource: url: jdbc:postgresql://localhost:5432/tracytd username: postgres password: tuasenha (substituir pela senha do postgres) Executar o comando mvn clean install no terminal do intellij. No intellij, ir at\u00e9 o menu Add Configuration, adicionar uma nova configura\u00e7\u00e3o (sinal + no canto superior esquerdo), selecionando a op\u00e7\u00e3o \"application\" No menu seguinte, complete os campos com essas instru\u00e7\u00f5es: name: \"tracy-api\" main class: procure a classe \"tracy application\" No campo \"Modify options\", escolha a op\u00e7\u00e3o \"Add vm options\", e no campo com o mesmo nome, cole o seguinte c\u00f3digo: -Dspring.profiles.active=dev Depois disso, clique em aplicar e ok. Se o campo \"Add configuration\" n\u00e3o mudar automaticamente, mude ele para a nova configura\u00e7\u00e3o. Rode o projeto!","title":"Primeiro Passo: Backend"},{"location":"config/tracy-api-installation/#segundo-passo-front-end","text":"Clone o reposit\u00f3rio tracy-front. (Em caso de problemas com a funcionalidade do git bash voc\u00ea pode usar o cmd para fazer isso) Abra o projeto com o Vs Code e execute o comando npm i . Isso vai levar alguns minutos para executar. Ap\u00f3s o t\u00e9rmino, execute o comando ng s . Isso vai demorar um pouco mais. Depois que terminar, abra seu navegador e v\u00e1 para \"localhost: 4200\" Coloque o login \"admin@tracytd.org\", e a senha \"rootadmin\" Est\u00e1 pronto!","title":"Segundo passo: Front End"},{"location":"config/tracy-api-installation/#como-conseguir-ajuda","text":"Voc\u00ea dever\u00e1 acessar o canal do Discord , onde ter\u00e1 acesso aos desenvolvedores trabalhando no projeto, assim como outras pessoas que est\u00e3o usando Tracy em suas empresas.","title":"Como conseguir ajuda?"},{"location":"config/tracy-api-installation/#gerenciamento-de-contribuicoes","text":"O projeto tem um conselho de gest\u00e3o do que deve ou n\u00e3o ser priorizado. Esse conjunto de desenvolvedores \u00e9 formado por pessoas com experi\u00eancia no c\u00f3digo e no produto. Com o tempo, voc\u00ea tamb\u00e9m poder\u00e1 ajudar ingressando no conselho de administra\u00e7\u00e3o.","title":"Gerenciamento de contribui\u00e7\u00f5es"},{"location":"config/tracy-api-installation/#processo-de-desenvolvimento-do-projeto","text":"Registro de uma edi\u00e7\u00e3o (issue); Once registered, the issue can receive comments from other people, to detail and improve the description of the new enhancement request, new feature or bug to be solved. Anyone can take up an open issue and implement their solution. Uma vez registrada, a edi\u00e7\u00e3o pode receber coment\u00e1rios de outras pessoas, para detalhar e melhorar a descri\u00e7\u00e3o da nova solicita\u00e7\u00e3o de aprimoramento, novo recurso ou bug para ser resolvido. Qualquer um pode assumir um problema aberto e implementar sua solu\u00e7\u00e3o. Atribui\u00e7\u00e3o de uma Edi\u00e7\u00e3o ; In Issues you will have the entire backlog of the project, and by clicking on an issue, you can assign it, in \"Assigness\". So, it will be your development responsibility. follow the guidelines on how to create a branch and make a pull request. Em edi\u00e7\u00f5es voc\u00ea ter\u00e1 todo os registros acumulados do projeto e, clicando em uma edi\u00e7\u00e3o, voc\u00ea pode atribuir ela em \"Atribuir\". Ent\u00e3o, ela ser\u00e1 sua responsabilidade de desenvolvimento. Siga as orienta\u00e7\u00f5es sobre como criar uma branch e fazer uma solicita\u00e7\u00e3o. (Pull request). Criando branch; To start development it is necessary to create a branch. There are, by default, three types of branches: hot, feat and bugfix: - hot -> hotfix: Branch prefix for quick and small code change; - feat -> feature: Branch prefix for new feature or improvement; - bugfix -> Branch prefix that fixes some bug in code. Knowing the prefixes for each issue type, fill in the branch name suffix with \"/#\", followed by the Issue number. Example: \"hot/#xxxx\", \"feat/#yyyy\", \"bugfix/#zzzz\". Para come\u00e7ar o desenvolvimento \u00e9 necess\u00e1rio criar uma branch. Aqui est\u00e3o, por padr\u00e3o, tr\u00eas tipos de branch: hot, feat e bugfix: - hot -> hotfix: Prefico de branch para pequenas e r\u00e1pidas mudan\u00e3s de c\u00f3digo. - feat -> feature: Prefixo de branch para nova funcionalidade ou aprimoramento. - bugfix -> Prefixo de branch que conserta algum tipo de bug no c\u00f3digo. Conhecendo os prefixos para cada tipo de edi\u00e7\u00e3o, complete o sufixo do nome da branch com \"/#\", seguido do n\u00famero da edi\u00e7\u00e3o. Exemplo: \"hot/#xxxx\", \"feat/#yyyy\", \"bugfix/#zzzz\". Fazendo Pull Request; Ap\u00f3s implementar sua solu\u00e7\u00e3o \u00e9 hora de fazer o Pull Request...","title":"Processo de desenvolvimento do projeto"},{"location":"config/tracy-front-instalation/","text":"Instala\u00e7\u00e3o - Tracy Front % TO DO","title":"Instala\u00e7\u00e3o - Tracy Front"},{"location":"config/tracy-front-instalation/#instalacao-tracy-front","text":"% TO DO","title":"Instala\u00e7\u00e3o - Tracy Front"}]}